["from collections import defaultdict as dd\nimport math\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\nn, q=mi()\n\nints=[]\n\n\nfor _ in range(q):\n\tst, end=mi()\n\tints.append((st,end))\n\n\ncoverage=[10]+[0]*n\n\nfor st, end in ints:\n\tfor i in range(st,end+1):\n\t\tcoverage[i]+=1\n\ntotal=-1\n\nfor val in coverage:\n\tif not val==0:\n\t\ttotal+=1\n\nsinglecount=0\ndoublecount=0\n\nsingles=[0]*(n+1)\n#print(total)\ndoubles=[0]*(n+1)\nfor i in range(len(coverage)):\n\t#print(i,singles)\n\tif coverage[i]==1:\n\t\tsinglecount+=1\n\tif coverage[i]==2:\n\t\tdoublecount+=1\n\tsingles[i]=singlecount\n\tdoubles[i]=doublecount\nmaxtotal=0\nfor i in range(len(ints)):\n\tfor j in range(i+1, len(ints)):\n\t\tst1=min(ints[i][0],ints[j][0])\n\t\tend1=min(ints[i][1],ints[j][1])\n\t\tst2, end2=max(ints[i][0],ints[j][0]), max(ints[i][1],ints[j][1])\n\t\t#assume st1<=st2\n\t\tif end1<st2:\n\t\t\tcurtotal=total-(singles[end1]-singles[st1-1])-(singles[end2]-singles[st2-1])\n\t\telif end1<end2:\n\t\t\tcurtotal=total-(singles[st2-1]-singles[st1-1])-(doubles[end1]-doubles[st2-1])-(singles[end2]-singles[end1])\n\t\telse:\n\t\t\tcurtotal=total-(singles[st2-1]-singles[st1-1])-(doubles[end2]-doubles[st2-1])-(singles[end1]-singles[end2])\n\t\tmaxtotal=max(maxtotal,curtotal)\n\nprint(maxtotal)\n\t\t\n\n\n\n\n\n\n\n", "import collections\n\nn , q  = list(map(int , input().split()))\nsections = [0]*n\np = []\nfor _ in range(q):\n    l , r = list(map(int , input().split()))\n    p.append((l,r))\n    for j in range(l,r+1):\n        sections[j-1]+=1\n\naux = n-collections.Counter(sections)[0]\nnumber1 = [0]*n\nnumber2 = [0]*n\n\nfor i in range(n):\n    if(sections[i]==1):\n        for j in range(i,n):\n            number1[j]+=1\n    elif(sections[i]==2):\n        for j in range(i,n):\n            number2[j]+=1\n\nans = -float('inf')\nfor i in range(len(p)):\n    for j in range(len(p)):\n        if(j>i):\n            a, b = p[i]\n            c, d = p[j]\n            if(a>c):\n                a , c = c , a\n                b , d = d , b\n            aux1 = number1[b-1]-number1[a-1]+1*(sections[a-1]==1)\n            aux2 = number1[d-1]-number1[c-1]+1*(sections[c-1]==1)\n            aux3 = abs(number2[c-1]-number2[min(b,d)-1])+1*(sections[c-1]==2)\n            if(b<c): aux3 = 0\n            ans = max(ans , aux-(aux1+aux2+aux3))\nprint(ans)\n", "DBG = False\nn,q = list(map(int,input().split()))\nl = []\nr = []\nc = [0] * (n+2)\nfor i in range(q):\n  ll,rr = list(map(int,input().split()))\n  l.append(ll)\n  r.append(rr)\n  for j in range(ll,(rr+1)):\n    c[j] += 1\n\nacc1 = [0] * (n+2)\nacc12 = [0] * (n+2)\nfor j in range(1,n+1):\n  acc1[j] = acc1[j-1] + (1 if c[j] == 1 else 0)\n  acc12[j] = acc12[j-1] + (1 if (c[j] == 2) else 0)\n\nminred = 99999999\nfor i in range(q-1):\n  for j in range(i+1,q):\n    li = l[i]\n    lj = l[j]\n    ri = r[i]\n    rj = r[j]\n    #puts \"(#{li} #{ri}) - (#{lj} #{rj}) \" if DBG\n    if li > lj:\n      li, lj = lj, li\n      ri, rj = rj, ri\n    #end  # now li <= lj\n\n    if rj <= ri:   # li  lj  rj  ri\n      oneal = li\n      onear = lj-1\n      twol = lj\n      twor = rj\n      onebl = rj+1\n      onebr = ri\n    elif lj <= ri:   #  li  lj  ri  rj\n      oneal = li\n      onear = lj-1\n      twol = lj\n      twor = ri\n      onebl = ri+1\n      onebr = rj\n    else:   #   li  ri    lj  rj\n      oneal = li\n      onear = ri\n      twol = lj\n      twor = lj-1  # null\n      onebl = lj\n      onebr = rj\n\n    onereda = acc1[onear] - acc1[oneal-1]\n    oneredb = acc1[onebr] - acc1[onebl-1]\n    twored = acc12[twor] - acc12[twol-1]\n    redsum = onereda + oneredb + twored\n    #puts \" - 1l: #{onereda}, 2:#{twored}, 1r: #{oneredb}\" if DBG\n    minred = min(minred, redsum)\n\nzcnt = 0\nfor i in range(1,n+1):\n  if c[i] == 0:\n      zcnt += 1\nprint(n-zcnt-minred)\n", "n,q=map(int,input().split())\narr=[]\nff=[0]*(5005)\nfor i in range(q):\n\tx,y=map(int,input().split())\n\tfor j in range(x,y+1):\n\t\tff[j]+=1\n\tarr.append([x,y])\nans=0\nfor i in range(q):\n\ttt=0\n\tfor j in range(arr[i][0],arr[i][1]+1):\n\t\tff[j]-=1\n\tfor j in range(5005):\n\t\tif ff[j]>0:\n\t\t\ttt+=1\n\tc=[0]*(n+1)\n\tfor j in range(1,n+1):\n\t\tc[j]=c[j-1]\n\t\tif ff[j]==1:\n\t\t\tc[j]+=1\n\t# print(ff[0:n+1])\n\tfor j in range(i+1,q):\n\t\tans=max(ans,tt-c[arr[j][1]]+c[arr[j][0]-1])\n\tfor j in range(arr[i][0],arr[i][1]+1):\n\t\tff[j]+=1\nprint(ans)", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom copy import copy\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN,Q=MAP()\n\nimos=[0]*(N+2)\nPts=[None]*Q\nfor i in range(Q):\n    l,r=MAP()\n    Pts[i]=(l,r)\n    imos[l]+=1\n    imos[r+1]-=1\nfor i in range(N+1):\n    imos[i+1]+=imos[i]\n\nmx=0\nfor i in range(Q):\n    cp=copy(imos)\n    l,r=Pts[i]\n    for j in range(l, r+1):\n        cp[j]-=1\n    sm=0\n    cnt1=[0]*(N+2)\n    for j in range(1, N+1):\n        if cp[j]>0:\n            sm+=1\n        if cp[j]==1:\n            cnt1[j]+=1\n        cnt1[j+1]+=cnt1[j]\n    for j in range(i+1, Q):\n        l2,r2=Pts[j]\n        mx=max(mx, sm-(cnt1[r2]-cnt1[l2-1]))\n\nprint(mx)\n", "n, q = map(int, input().split())\na = []\nfor i in range(q):\n    l, r = map(int, input().split())\n    l -= 1\n    r -= 1\n    a.append([l, r])\n\nct = [0] * (n + 1)\nfor i in a:\n    ct[i[0]] += 1\n    ct[i[1] + 1] -= 1\n\nones, twos = [0] * n, [0] * n\ns = 0\nfor i in range(n):\n    if i > 0:\n        ct[i] += ct[i - 1]\n        ones[i] += ones[i - 1]\n        twos[i] += twos[i - 1]\n    if ct[i] == 1:\n        ones[i] += 1\n    elif ct[i] == 2:\n        twos[i] += 1\n    if ct[i] != 0:\n        s += 1\n\nones.append(0)\ntwos.append(0)\n\nans = 0\nfor i in range(q):\n    for j in range(i + 1, q):\n        rem = 0;\n        rem += ones[a[i][1]] - ones[a[i][0] - 1]\n        rem += ones[a[j][1]] - ones[a[j][0] - 1]\n\n        l, r = max(a[i][0], a[j][0]), min(a[i][1], a[j][1])\n        if r >= l:\n            rem += twos[r] - twos[l - 1]\n        \n        ans = max(ans, s - rem)\n\nprint(ans)", "n, q = list(map(int, input().split()))\npainters = []\nsections = [0] * (n + 1)\nfor i in range(q):\n    l, r = list(map(int, input().split()))\n    l -= 1\n    r -= 1\n    painters.append([l, r])\n    sections[l] += 1\n    sections[r + 1] -= 1\n\ncnt1 = [0] * (n + 1)\ncnt2 = [0] * (n + 1)\np = 0\ntotal = 0\nfor i in range(n):\n    p += sections[i]\n    if p == 1:\n        cnt1[i + 1] = cnt1[i] + 1\n    else:\n        cnt1[i + 1] = cnt1[i]\n    if p == 2:\n        cnt2[i + 1] = cnt2[i] + 1\n    else:\n        cnt2[i + 1] = cnt2[i]\n    if p > 0:\n        total += 1\nans = 0\nfor i in range(q - 1):\n    for j in range(i + 1, q):\n        [l1, r1] = painters[i]\n        [l2, r2] = painters[j]\n        l = max(l1, l2)\n        r = min(r1, r2)\n        if l <= r:\n            t = total - (cnt2[r + 1] - cnt2[l]) - (cnt1[max(r1, r2) + 1] - cnt1[min(l1, l2)])\n            ans = max(ans, t)\n        else:\n            t = total - (cnt1[r1 + 1] - cnt1[l1]) - (cnt1[r2 + 1] - cnt1[l2])\n            ans = max(ans, t)\nprint(ans)\n", "from operator import itemgetter\nn,q=list(map(int,input().split()))\ncnt=0\nans=[0]*(n)\narr=[0]*q\nfor i in range(q):\n\tarr[i]=list(map(int,input().split()))\n\tfor j in range(arr[i][0]-1,arr[i][1],1):\n\t\tans[j]+=1\n\t\tif ans[j]==1:\n\t\t\tcnt+=1\ncnt1=[0]*(n+1)\ncnt2=[0]*(n+1)\n# print(\"ans\",*ans)\nfor i in range(n):\n\tcnt1[i+1]=cnt1[i]\n\tcnt2[i+1]=cnt2[i]\n\tif ans[i]==1:\n\t\tcnt1[i+1]+=1\n\tif ans[i]==2:\n\t\tcnt2[i+1]+=1\n# print(cnt2)\nmac=0\nfor i in range(q):\n\tfor j in range(i+1,q,1):\n\t\tdelete=cnt1[arr[i][1]]-cnt1[arr[i][0]-1]+cnt1[arr[j][1]]-cnt1[arr[j][0]-1]\n\t\tif arr[j][0]>arr[i][1] or arr[j][1]<arr[i][0]:\n\t\t\tpass\n\t\telif arr[j][0]<=arr[i][1]:\n\t\t\t# print(\"****\",cnt2[min(arr[i][1],arr[j][1])],cnt2[max(arr[j][0]-1,arr[i][0]-1)])\n\t\t\tdelete+=cnt2[min(arr[i][1],arr[j][1])]-cnt2[max(arr[j][0]-1,arr[i][0]-1)]\n\n\t\t# print(i,j,delete)\n\t\tif cnt-delete>mac:\n\t\t\tmac=cnt-delete\nprint(mac)\n\n\n\n\n", "n,q=list(map(int,input().split()))\nsec=[list(map(int,input().split())) for _ in range(q)]\nsec=sorted(sec,key=lambda x:(x[0],x[1]))\nfence=[0]*(n+1)\nfor i in sec:\n    x,y=i[0],i[1]\n    x-=1;y-=1\n    fence[x]+=1\n    fence[y+1]-=1\nfor i in range(1,n+1):\n    fence[i]+=fence[i-1]\nzeroes=[0]*(n);ones=[0]*(n);twos=[0]*(n)\nzeroes[0]=1 if fence[0]==0 else 0\nones[0]=1 if fence[0]==1 else 0\ntwos[0]=1 if fence[0]==2 else 0\nfor i in range(1,n):\n    if fence[i]==0:\n        zeroes[i]+=zeroes[i-1]+1\n    else:\n        zeroes[i]=zeroes[i-1]\n\nfor i in range(1,n):\n    if fence[i]==1:\n        ones[i]+=ones[i-1]+1\n    else:\n        ones[i]=ones[i-1]\n\nfor i in range(1,n):\n    if fence[i]==2:\n        twos[i]+=twos[i-1]+1\n    else:\n        twos[i]=twos[i-1]\nnp=0\nfor i in range(q):\n    x1,y1=sec[i][0],sec[i][1]\n    x1-=1;y1-=1\n    co1=co2=ct=0\n    for j in range(i+1,q):\n        x2,y2=sec[j][0],sec[j][1]\n        x2-=1;y2-=1\n        co1=ones[y1]-(0 if x1==0 else ones[x1-1])\n        co2=ones[y2]-(0 if x2==0 else ones[x2-1])\n        if x2<=y1:\n            ct=twos[min(y1,y2)]-(0 if x2==0 else twos[x2-1])\n        else:\n            ct=0\n        np=max(np,n-(co1+co2+ct+zeroes[-1]))\n        #print(i,j,np,co1,co2,ct,zeroes[-1],x2,y1)\nprint(np)\n    \n        \n    \n", "n,q=list(map(int,input().split()))\nsec=[list(map(int,input().split())) for _ in range(q)]\nsec=sorted(sec,key=lambda x:(x[0],x[1]))\nfence=[0]*(n+1)\nfor i in sec:\n    x,y=i[0],i[1]\n    x-=1;y-=1\n    fence[x]+=1\n    fence[y+1]-=1\nfor i in range(1,n+1):\n    fence[i]+=fence[i-1]\nzeroes=[0]*(n);ones=[0]*(n);twos=[0]*(n)\nzeroes[0]=1 if fence[0]==0 else 0\nones[0]=1 if fence[0]==1 else 0\ntwos[0]=1 if fence[0]==2 else 0\nfor i in range(1,n):\n    if fence[i]==0:\n        zeroes[i]+=zeroes[i-1]+1\n    else:\n        zeroes[i]=zeroes[i-1]\n\nfor i in range(1,n):\n    if fence[i]==1:\n        ones[i]+=ones[i-1]+1\n    else:\n        ones[i]=ones[i-1]\n\nfor i in range(1,n):\n    if fence[i]==2:\n        twos[i]+=twos[i-1]+1\n    else:\n        twos[i]=twos[i-1]\nnp=0\nfor i in range(q):\n    x1,y1=sec[i][0],sec[i][1]\n    x1-=1;y1-=1\n    co1=co2=ct=0\n    for j in range(i+1,q):\n        x2,y2=sec[j][0],sec[j][1]\n        x2-=1;y2-=1\n        co1=ones[y1]-(0 if x1==0 else ones[x1-1])\n        co2=ones[y2]-(0 if x2==0 else ones[x2-1])\n        if x2<=y1:\n            ct=twos[min(y1,y2)]-(0 if x2==0 else twos[x2-1])\n        else:\n            ct=0\n        np=max(np,n-(co1+co2+ct+zeroes[-1]))\n        #print(i,j,np,co1,co2,ct,zeroes[-1],x2,y1)\nprint(np)\n", "n, m = list(map(int, input().split()))\na = [0 for i in range(n)]\nb = [list(map(int, input().split())) for i in range(m)] \nf = [0 for i in range(m)]\ng = [[0 for i in range(m)] for j in range(m)]\nans = s = p = q = 0\nc = n\nfor i in range(m):\n\tfor j in range(b[i][0] - 1, b[i][1]):\n\t\ta[j] += 1\nfor i in range(n):\n\ts += a[i] != 0\n\tif a[i] == 1:\n\t\tfor j in range(m):\n\t\t\tif b[j][0] - 1 <= i < b[j][1]:\n\t\t\t\tf[j] += 1\n\tif a[i] == 2:\n\t\tp = q = -1\n\t\tfor j in range(m):\n\t\t\tif b[j][0] - 1 <= i < b[j][1]:\n\t\t\t\tif p == -1:\n\t\t\t\t\tp = j\n\t\t\t\telse:\n\t\t\t\t\tq = j\n\t\tg[p][q] += 1\nfor i in range(m):\n\tfor j in range(i + 1, m):\n\t\tc = min(c, g[i][j] + f[i] + f[j])\nprint(s - c)\n", "n,q = map(int, input().strip().split())\ncount = [0 for i in range(n+1)]\ntot = 0\npainters = []\nfor i in range(q):\n    l,r = map(int, input().strip().split())\n    painters.append([l,r])\n    for j in range(l,r+1):\n        if count[j] == 0:\n            tot += 1\n        count[j] += 1\nones = [0 for i in range(n+1)]\ntwos = [0 for i in range(n+1)]\npainters.sort()\nfor i in range(1,n+1):\n    ones[i] = ones[i-1]\n    twos[i] = twos[i-1]\n    if count[i] == 1:\n        ones[i] += 1\n    elif count[i] == 2:\n        twos[i] += 1\nmx = 0\nfor i in range(q):\n    for j in range(i+1,q):\n      a = ones[painters[i][1]] - ones[painters[i][0]-1]\n      b = ones[painters[j][1]] - ones[painters[j][0]-1]\n      if painters[j][0] <= painters[i][1]:\n          c = twos[min(painters[i][1],painters[j][1])] - twos[painters[j][0]-1]\n      else:\n          c = 0\n      mx = max(mx,tot - a -b -c)\nprint (mx)", "n,q = [int(x) for x in input().split()]\n\np = []\n\nfor _ in range(q):\n    p.append([int(x)-1 for x  in input().split()])\n\n\ndef pre(ind):\n    res = [0 for _ in range(n)]\n    for i in range(q):\n        if i == ind : continue\n        res[p[i][0]] += 1\n        if p[i][1] + 1 < n:\n            res[p[i][1] + 1] -= 1\n    t = 0\n    total = 0\n    for i in range(n):\n        t += res[i]\n        res[i] = t\n        if res[i] > 0:\n            total += 1\n    for i in range(n):\n        if res[i] > 1 : res[i] = 0\n    for i in range(1,n):\n        res[i] += res[i-1]\n    return total,res\n\n\nbest = 0\n\nfor i in range(q):\n    total,table = pre(i)\n    for j in range(q):\n        if j== i : continue\n        count = table[p[j][1]]\n        if p[j][0] > 0 :\n            count -= table[p[j][0] - 1] \n        best = max(best,total-count)\n\nprint(best)\n", "n, q = list(map(int, input().split()))\nC = [0 for _ in range(n)]\nX = [[-1, -1] for _ in range(n)]\nii = 1\nfor i in range(q):\n    l, r = list(map(int, input().split()))\n    ii += 1\n    l -= 1\n    r -= 1\n    for j in range(l, r+1):\n        if C[j] <= 2:\n            C[j] += 1\n            if C[j] <= 2:\n                X[j][C[j]-1] = i\ns = len([c for c in C if c > 0])\n\nma = 0\nfor i in range(q):\n    Y = [0] * q\n    Y[i] = 10**10\n    y = 0\n    for j in range(n):\n        if C[j] == 2:\n            if i == X[j][0] or i == X[j][1]:\n                Y[X[j][0]] += 1\n                Y[X[j][1]] += 1\n        elif C[j] == 1:\n            if i == X[j][0]:\n                y += 1\n            else:\n                Y[X[j][0]] += 1\n            \n    ma = max(ma, s-min(Y)-y)\n\nprint(ma)\n", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/7 13:43\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Painting the Fence.py\n\n\ndef main():\n    n, q = list(map(int, input().split()))\n    painters = []\n    for _ in range(q):\n        painters.append(list(map(int, input().split())))\n    # print(painters)\n\n    ret = 0\n    for index in range(q):\n        mask = [0] * (n + 1)\n        for i in range(q):\n            if i == index:\n                continue\n            left, right = painters[i]\n            mask[left - 1] += 1\n            mask[right] -= 1\n\n        curr_sum, paint_count = 0, 0\n        section_count = [0] * n\n        for i in range(n):\n            curr_sum += mask[i]\n            section_count[i] = curr_sum\n            if section_count[i] > 0:\n                paint_count += 1\n\n        one_count = [0] * (n + 1)\n        for i in range(n):\n            one_count[i + 1] = one_count[i] + (1 if section_count[i] == 1 else 0)\n\n        desc_ones = n\n        for i in range(q):\n            if i == index:\n                continue\n            left, right = painters[i]\n            desc_ones = min(desc_ones, one_count[right] - one_count[left - 1])\n\n        ret = max(ret, paint_count - desc_ones)\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\n\ndef get_intersection(l1, r1, l2, r2):\n    if min(r1, r2) < max(l1, l2):\n        return -1, -1\n    else:\n        return max(l1, l2), min(r1, r2)\n\ndef cumsum(ones, l, r):\n    ans = ones[r]\n    if l != 1:\n        ans -= ones[l-1]\n\n    return ans\n\ndef main():\n\n    n,q = [int(x) for x in input().split(' ')]\n    cnts = [0 for i in range(n+1)]\n    pep = []\n\n    for i in range(q):\n        l,r = [int(x) for x in input().split(' ')]\n        pep.append((l,r))\n        cnts[l] += 1\n        if r != n:\n            cnts[r+1] -= 1\n\n    ones = [0 for i in range(n+1)]\n    twos = [0 for i in range(n+1)]\n    tot = 0\n\n    for i in range(1, n+1):\n        cnts[i] += cnts[i-1]\n        tot += cnts[i] != 0\n\n        if cnts[i] == 1:\n            ones[i] += 1\n        elif cnts[i] == 2:\n            twos[i] += 1\n\n        ones[i] += ones[i-1]\n        twos[i] += twos[i-1]\n\n    best = -1\n    for i in range(len(pep)):\n        for j in range(i+1, len(pep)):\n            cur_ans = tot - cumsum(ones, *pep[i])\n            cur_ans -= cumsum(ones, *pep[j])\n\n            l, r = get_intersection(*pep[i], *pep[j])\n\n            if l != -1:\n                cur_ans -= cumsum(twos, l, r)\n\n            best = max(best, cur_ans)\n\n    print(best)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, q = map(int, input().split())\n    cnt = [0] * (n+1)\n    ll = [0] * q\n    rr = [0] * q\n\n    for i in range(q):\n        l, r = map(int, input().split())\n        cnt[l] += 1\n        if r < n:\n            cnt[r+1] -= 1\n        ll[i] = l\n        rr[i] = r\n\n    for i in range(1, n+1):\n        cnt[i] += cnt[i-1]\n\n    pref1 = [0] * (n+1)\n    pref2 = [0] * (n+1)\n    for i in range(1, n+1):\n        if cnt[i] == 1:\n            pref1[i] = 1\n        pref1[i] += pref1[i-1]\n\n        if cnt[i] == 2:\n            pref2[i] = 1\n        pref2[i] += pref2[i-1]\n\n    all = 0\n    for i in range(1, n+1):\n        if cnt[i] > 0:\n            all += 1\n\n\n    def getIntersection(l1, r1, l2, r2):\n        start = max(l1, l2)\n        end = min(r1, r2)\n        if start <= end:\n            return start, end\n        return None\n\n\n    maxBlocks = 0\n    for i in range(q):\n        for j in range(i+1, q):\n            all_ij = all\n            inter = getIntersection(ll[i], rr[i], ll[j], rr[j])\n            if inter:\n                interL, interR = inter\n                all_ij -= (pref1[interL-1] - pref1[min(ll[i], ll[j])-1])\n                all_ij -= (pref1[max(rr[i], rr[j])] - pref1[interR])\n                all_ij -= (pref2[interR] - pref2[interL-1])\n            else:\n                all_ij -= (pref1[rr[i]] - pref1[ll[i]-1])\n                all_ij -= (pref1[rr[j]] - pref1[ll[j]-1])\n\n            maxBlocks = max(maxBlocks, all_ij)\n\n    print(maxBlocks)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport copy\ninput = sys.stdin.readline\n\nn,q=list(map(int,input().split()))\nQ=[list(map(int,input().split())) for i in range(q)]\nQ.sort()\n\nLIST=[0]*(n+2)\nfor l ,r in Q:\n    LIST[l]+=1\n    LIST[r+1]-=1\n\nSUM=[0]\nfor i in range(1,n+2):\n    SUM.append(LIST[i]+SUM[-1])\n\nONES=[0]\nTWOS=[0]\n\nfor i in range(1,n+2):\n    if SUM[i]==1:\n        ONES.append(ONES[-1]+1)\n    else:\n        ONES.append(ONES[-1])\n\n    if SUM[i]==2:\n        TWOS.append(TWOS[-1]+1)\n    else:\n        TWOS.append(TWOS[-1])\n\nANS=sum([1 for a in SUM if a>=1])\nMINUS=10**10\nfor i in range(q-1):\n    for j in range(i+1,q):\n        l0,r0=Q[i][0],Q[i][1]\n        l1,r1=Q[j][0],Q[j][1]\n\n        if l1>r0:\n            MICAN=(ONES[r0]-ONES[l0-1])+(ONES[r1]-ONES[l1-1])\n\n        elif l1<=r0 and r1>r0:\n            MICAN=(ONES[l1-1]-ONES[l0-1])+(TWOS[r0]-TWOS[l1-1])+(ONES[r1]-ONES[r0])\n\n        elif l1<=r0 and r1<=r0:\n            MICAN=(ONES[l1-1]-ONES[l0-1])+(TWOS[r1]-TWOS[l1-1])+(ONES[r0]-ONES[r1])\n\n        if MICAN<MINUS:\n            MINUS=MICAN\n            \n        #print(i,j)\n        #print(l0,r0,l1,r1)\n        #print(MICAN)\n\nprint(ANS-MINUS)\n                                                    \n                                                                                 \n        \n\n\n\n\n", "\ndef __starting_point():\n    N,Q = list(map(int,input().strip().split()))\n    \n    painters = []\n    for i in range(Q):\n        painters.append(tuple(map(int,input().strip().split())))\n    C = [[] for i in range(N+1)]\n    for i in range(len(painters)):\n        start,end = painters[i]\n        for j in range(start,end+1):\n            C[j].append(i)\n    C = C[1:]\n    total = sum(1 for i in C if len(i) > 0)\n    count = [[0 for i in range(Q)] for j in range(Q)]\n    for i in range(N):\n        if len(C[i]) == 2:\n            count[C[i][0]][C[i][1]] += 1\n            count[C[i][1]][C[i][0]] += 1\n        if len(C[i]) == 1:\n            for j in range(Q):\n                if j != C[i][0]:\n                    count[C[i][0]][j] += 1\n                    count[j][C[i][0]] += 1\n    mini = 100000\n    for i in range(Q):\n        for j in range(Q):\n            if i != j and count[i][j] < mini:\n                mini = count[i][j]\n    print(total - mini)\n    \n\n__starting_point()", "n, q = list(map(int, input().split()))\na = []\nar = [0 for i in range(n + 1)]\nfor i in range(q):\n    l, r = list(map(int, input().split()))\n    l -= 1\n    r -= 1\n    a.append((l, r))\n    ar[l] += 1\n    ar[r + 1] += -1\nplus = 0\nfor i in range(n):\n    plus += ar[i]\n    ar[i] = plus\n\nans = 0\n\nfor i in range(q):\n    for j in range(a[i][0], a[i][1] + 1):\n        ar[j] -= 1\n\n    pref = [0]\n    count = 0\n    for pos in range(n):\n        if ar[pos] > 0:\n            count += 1\n\n        value = 0\n        if ar[pos] == 1:\n            value = 1\n        pref.append(value + pref[-1])\n\n    for pos in range(q):\n        if pos != i:\n            ans = max(ans, count - (pref[a[pos][1] + 1] - pref[a[pos][0]]))\n\n    for j in range(a[i][0], a[i][1] + 1):\n        ar[j] += 1\n\nprint(ans)\n", "cnt = lambda s, x: s.count(x)\nii = lambda: int(input())\nsi = lambda: input()\nf = lambda: list(map(int, input().split()))\ndgl = lambda: list(map(int, input()))\nil = lambda: list(map(int, input().split()))\nn,k=f()\nl=[0]*(n+10)\np=[]\nmx=0\nfor _ in range(k):\n    a,b=f()\n    p.append([a,b])\n    l[a]+=1\n    l[b+1]-=1\n\npsf=[l[0]]\n\nfor _ in range(1,n+2):\n    psf.append(psf[-1]+l[_])\n\nw=sum(i>0 for i in psf)\n\npsf1,psf2=[0],[0]\nfor i in range(1,n+2):\n    if psf[i]==1:\n        psf1.append(psf1[-1]+1)\n    else:\n        psf1.append(psf1[-1])\n    if psf[i]==2:\n        psf2.append(psf2[-1]+1)\n    else:\n        psf2.append(psf2[-1])\n\n\nfor i in range(k-1):\n    for j in range(i+1,k):\n        x=w-(psf1[p[i][1]]-psf1[p[i][0]-1])-(psf1[p[j][1]]-psf1[p[j][0]-1])\n        l,r=max(p[i][0],p[j][0]),min(p[i][1],p[j][1])\n        if l<=r:\n            x+=psf1[r]-psf1[l-1]\n            x-=psf2[r]-psf2[l-1]\n        mx=max(x,mx)\n\n\nprint(mx)\n", "import sys\n# sys.stdin = open('input.txt')\nn, q = list(map(int, input().split()))\nscanline = [0] * n\nmal = []\nans = 0\nfor i in range(q):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    mal.append((a, b))\n    scanline[a] += 1\n    if b < n:\n        scanline[b] -= 1\n\nfor i in range(q):\n    scanline[mal[i][0]] -= 1\n    if mal[i][1] < n:\n        scanline[mal[i][1]] += 1\n    ots = [0] * (n + 1)\n    not0 = 0\n    cur = 0\n    inans = -10000000000\n    # print(scanline)\n    for j in range(1, n + 1):\n        cur += scanline[j - 1]\n        if cur != 0:\n            not0 += 1\n        if cur == 1:\n            ots[j] = ots[j - 1] + 1\n        else:\n            ots[j] = ots[j - 1]\n    # print(ots)\n    for j in range(q):\n        if j == i:\n            continue\n        inans = max(inans, ots[mal[j][0]] - ots[mal[j][1]])\n    # print(inans)\n    ans = max(ans, inans + not0)\n    scanline[mal[i][0]] += 1\n    if mal[i][1] < n:\n        scanline[mal[i][1]] -= 1\nprint(ans)\n", "n,q=list(map(int,input().split()))\na=[list(map(int,input().split())) for _ in range(q)]\nc=[0]*5005\nfor i in range(q):\n    for j in range(a[i][0],a[i][1]+1):\n        c[j]+=1\nans=0\nfor i in range(q):\n    tmp=0\n    d=c[:]\n    for j in range(a[i][0],a[i][1]+1):\n        d[j]-=1\n    for j in range(5005):\n        if d[j]>0:tmp+=1\n    b=[0]*5005\n    for j in range(1,n+1):\n        b[j]=b[j-1]\n        if d[j]==1:b[j]+=1\n    for j in range(i+1,q):\n        ans=max(ans,tmp-b[a[j][1]]+b[a[j][0]-1])\nprint(ans)\n"]